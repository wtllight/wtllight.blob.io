<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	
  	
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html"></a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-05-16T14:38:02+08:00" itemprop="datePublished">2017/5/16</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14949166826374.html" itemprop="url">
		第十五章  iOS访问通讯录</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li>通讯录保存在SQLite3数据库中，不能使用数据持久化技术进行访问，而是使用专门API</li>
<li>iOS 9 之前使用的API为具有C风格的AddressBook与AddressBookUI</li>
<li>iOS 9 之后使用的API为框架Contacts与ContactsUI</li>
<li></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-05-16T09:18:44+08:00" itemprop="datePublished">2017/5/16</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14948975245100.html" itemprop="url">
		第十四章 本地化</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li>本地化API，NSLocale ， NSDateFormatter， NSNumberFormatter</li>
<li>有效实用InfoPlist.strings文件</li>
<li>Main.strings</li>
<li>Create String File:Localizable.strings</li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-05-15T15:20:21+08:00" itemprop="datePublished">2017/5/15</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14948328212551.html" itemprop="url">
		第十三章 应用程序设置</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li><p>设置，配置</p>

<pre><code>1. 设置，从Home进入进行设置
2. 配置，在应用中直接进行设置
</code></pre></li>
<li><p>应用程序设置包</p>

<pre><code>1. Settings Bundle
2. Root.plist , Root.strings
3. Root.plist 设置项目描述
4. Root.strings 应用本地化
</code></pre></li>
<li><p>设置项目种类</p>

<pre><code>1. 组，文本字段，标题，滑块，开关，值列表，子界面
2. 文本字段，Type PSTextFieldSpecifier组，用户名与密码
3. 开关，Type PSToggleSwitchSpecifier
4. 滑块，Type PSSliderSpecifier，图片需直接copy进Settings.bundle
5. 值列表，Type  PSMultiValueSpecifier
6. 子界面，Type PSChildPaneSpecifier， File fileName, 
another plist file Named fileName, need copy进Settings.bundle
</code></pre></li>
<li><p>读取设置</p>

<pre><code>1. NSUserDefaults
2. 
</code></pre></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-04-29T08:55:04+08:00" itemprop="datePublished">2017/4/29</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14934273040607.html" itemprop="url">
		apache set HTTPS</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><a href="http://blog.csdn.net/klshuo/article/details/50903141">http://blog.csdn.net/klshuo/article/details/50903141</a><br/>
<a href="http://blog.csdn.net/logico/article/details/52179603">http://blog.csdn.net/logico/article/details/52179603</a> <br/>
<a href="http://blog.csdn.net/zhu410289616/article/details/46566073">http://blog.csdn.net/zhu410289616/article/details/46566073</a></p>

<p>python -m SimpleHTTPServer<br/>
<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a></p>

<ol>
<li><p>Start Apache</p>

<pre><code>1. sudo apachectl start
2. http://127.0.0.1
3. /Library/WebServer/Documents/
4. 
</code></pre></li>
<li><p>sudo apachectl start</p></li>
<li><p>sudo apachectl restart</p></li>
<li><p>sudo apachectl stop</p></li>
<li><p>releaseNotesLink</p>

<pre><code>&lt;item&gt;
    &lt;title&gt;Version 1.2.4&lt;/title&gt;
    &lt;sparkle:releaseNotesLink&gt;https://example.com/release_notes_test.html&lt;/sparkle:releaseNotesLink&gt;
    &lt;pubDate&gt;Mon, 28 Jan 2013 14:30:00 +0500&lt;/pubDate&gt;
    &lt;sparkle:version&gt;1.2.4&lt;/sparkle:version&gt;
    &lt;link&gt;https://example.com/manual_update_info.html&lt;/link&gt;
&lt;/item&gt;
</code></pre></li>
<li><p>Embedded release notes</p>

<pre><code>    &lt;item&gt;
        &lt;title&gt;Version 2.0 (2 bugs fixed; 3 new features)&lt;/title&gt;
        &lt;description&gt;&lt;![CDATA[
            &lt;h2&gt;New Features&lt;/h2&gt;
            ...
            ]]&gt;
        &lt;/description&gt;
        ...
    &lt;/item&gt;
</code></pre></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-04-27T16:46:39+08:00" itemprop="datePublished">2017/4/27</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14932827993088.html" itemprop="url">
		第十二章 数据持久化</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li><p>概述</p>

<ol>
<li><p>沙盒目录</p>

<pre><code>1. 沙盒目录是一种数据安全策略，HTML5 浏览器同样采用沙盒设计
2. 特有的应用需要特有的API进行访问
</code></pre></li>
</ol></li>
<li><p>使用SQLite 数据库</p>

<ol>
<li><p>SQLite</p>

<pre><code>1. SQLite是关系型数据库，最初是为嵌入式系统所使用，目前为SQLite3
2. SQLite是开源的，采用C语言编写，可移植性强，可靠性高，小而易用
3. SQLite运行时与应用程序共用相同的进程空间
4. SQLite提供了对SQL-92标准的支持，支持多表，索引，事务，视图和触发
5. SQLite是无数据类型的数据库，即字段不用指定类型
</code></pre></li>
<li><p>SQLite数据类型</p>

<pre><code>1. SQLite可以忽略数据类型，但是从编程规范上讲，应该在CREATE TABLE语句中指定数据类型
2. 数据类型可以表明这个字段的含义，便于阅读和代码的理解
3. INTEGER  有符号的整数类型
4. REAL 浮点类型
5. TEXT 字符串类型，utf-8,uutf-16
6. BLOB 二进制大对象类型
7. SQLite中没有Boolen类型，可以采用整型0,1替代
8. 为了兼容SQL-92,中的其他数据类型，类型转换如下
9. VARCHAR,CHAR,CLOB -&gt; TEXT
10. FLOAT,DOUBLE -&gt; REAL
11. NUMBER -&gt; INTEGER,REAL
</code></pre></li>
<li><p>配置Objc 框架工程环境</p>

<pre><code>1. Targrts-&gt;Build Phases-&gt;Link Binary With Libraries-&gt;Add &quot;SQLite3.tbd&quot;
2. Build Settings-&gt;MACH_O_TYPE -&gt;mh_dylib(staticlib,default)
3. llvm Module
4. Build Settings -&gt; Search Paths -&gt; &quot;${SRCROOT}/module/Path&quot;
5. “${SRCROOT}”表示工程源程序路径，即Project.xcodeproj的路径
</code></pre></li>
<li><p>创建数据库</p>

<pre><code>1. 创建数据库，&quot;sqlite3_open(cpath, &amp;db)&quot;
2. 执行SQL语句，“sqlite3_exec(db, csql, NULL, NULL, NULL)”
3. 释放资源，“sqlite3_close(db)”
</code></pre></li>
<li><p>查询数据</p>

<ol>
<li>查询数据有查询条件，可以使用SQL语句的where子句实现，但是需要动态绑定参数</li>
<li><p>查询语句的具体操作步骤</p>

<pre><code>1. 打开数据库 &quot;sqlite3_open(cpath, &amp;db) != SQLITE_OK&quot;
2. 预处理SQL语句 &quot;sqlite3_prepare_v2(db, csql, -1, &amp;statement, NULL)&quot;
3. 绑定参数 &quot;sqlite3_bind_text(statement, 1, cDate, -1, NULL);&quot;
4. 执行SQL语句 &quot;sqlite3_step(statement) == SQLITE_ROW&quot;
5. 提取字段数据 &quot;sqlite3_column_text(statement, 0)&quot;
6. 释放资源 &quot;sqlite3_finalize(statement);sqlite3_close(db);&quot;
</code></pre></li>
<li><p>读取字段函数与字段类型</p>

<pre><code>1. sqlite3_column_text(sqlite3_stmt *, int iCol)
2. sqlite3_column_double(sqlite3_stmt *, int iCol)
3. sqlite3_column_int(sqlite3_stmt *, int iCol)
4. sqlite3_column_int64(sqlite3_stmt *, int iCol)
5. sqlite3_column_text(sqlite3_stmt *, int iCol)
6. sqlite3_column_text16(sqlite3_stmt *, int iCol)
</code></pre></li>
<li><p><a href="http://www.sqlite.org/cintro.html">Other API</a></p></li>
</ol></li>
<li><p>修改数据</p>

<pre><code>    1. 打开数据库 &quot;sqlite3_open(cpath, &amp;db) != SQLITE_OK&quot;
    2. 预处理SQL语句 &quot;sqlite3_prepare_v2(db, csql, -1, &amp;statement, NULL)&quot;
    3. 绑定参数 &quot;sqlite3_bind_text(statement, 1, cDate, -1, NULL);&quot;
    4. 执行SQL语句 &quot;sqlite3_step(statement) == SQLITE_ROW&quot;
    5. 释放资源 &quot;sqlite3_finalize(statement);sqlite3_close(db);&quot;
</code></pre></li>
</ol></li>
<li><p>Core     Data</p>

<ol>
<li><p>ORM</p>

<pre><code>1. Core Data 是Apple 为iOS ，OSX 开发的数据持久化技术，底层为SQLite数据库
2. CoreData 是一种ORM ， 对象关系映射

AppleswSet0701
185106686
</code></pre></li>
</ol></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-04-26T10:22:53+08:00" itemprop="datePublished">2017/4/26</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14931733733501.html" itemprop="url">
		第十一章 iOS 分层架构设计</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h6 id="toc_0">简介</h6>

<pre><code>    1. 设计模式只是解决某一特定问题的策略，是面向局部的
    2. 架构是宏观的，面向整个应用程序的，需要将各种设计模式组合起来
    3. 考虑到应用的可复用性与可扩展性，可采用分层架构设计
</code></pre>

<ol>
<li><p>低耦合企业级系统架构设计</p>

<pre><code>1. 表示层，交互组件View，不应该具有业务逻辑，指令与导航
2. 业务逻辑层，Controller核心业务处理层，指令，导航，Data
3. 数据持久层，用于访问信息系统层，数据库或文件操作
4. 信息系统层，数据来源，数据库，文件，网络数据
</code></pre></li>
<li><p>iOS分层架构设计</p>

<pre><code>1. 表示层，UIKit Framework
2. 业务逻辑层，框架封装
3. 数据持久层，提供本地或网络数据访问，SQLLite API，CoreData，Http，NSFileManager
4. 信息系统层，SQLite3 ，文件系统，云服务，Web服务
5. 设计模式，工程，工作空间，静态链接库，框架
</code></pre>

<ol>
<li><p>工程与工作空间</p>

<pre><code>1. 使用Xcode创建的Project称为工程，文件后缀.xcodeproj
2. 也可以创建WorkSpace，称为工作空间,文件后缀.xcworkspace
</code></pre></li>
<li><p>静态链接库</p>

<pre><code>1. static library，statically-linked library静态链接库
2. framework 框架
3. 库是一种没有main函数的程序代码的集合，
4. 静态链接库可以编译到你的执行代码中，动态链接库不能编译到你的执行代码中
5. 注意:  静态链接库中不能有swift代码块，只能是object c 代码模块
</code></pre></li>
<li><p>框架</p>

<pre><code>1. 为了使用方便，框架会将.a与.h文件打包在一起
2. Apple 提供的API都是框架
</code></pre></li>
<li><p>16种分层模式</p>

<pre><code>1. 纯Swift
2. 纯Objective C
3. 采用Swift调用Objective C
4. 采用Objective C调用Swift
5. OOO，OC实现表示层，业务逻辑层，数据持久层
6. SSS
7. SOO
8. OSS
9. 同一工作空间不同工程
10. 同一工程不同目标
11. 同一工程 P
12. WL WorkSpace Library
13. WorkSpace Framework
14. Target Library
15. Target Framework
</code></pre></li>
</ol></li>
<li><p>实例MyNotes</p>

<pre><code>1. 功能，增加，删除，查询
2. 两种平台iPhone与iPad原型设计，只介绍iPhone
</code></pre></li>
<li><p>基于同一工程的分层</p>

<pre><code>1. 创建工程MyNotes，
2. 表示层PresentationLayer，显示数据
3. 业务逻辑层BusinessLogicLayer，业务处理方法
4. 数据持久层PersistenceLayer，dao数据访问对象单例模式与domin实体类
5. 单例模式，Dao中NoteDao
            static NoteDAO* sharedSingleton = nil;
            static dispatch_once_t onceToken;
            dispatch_once(&amp;onceToken, ^{
            sharedSingleton = [[self alloc]init];
            });
6. 业务逻辑层，NoteBL，增删改
7. 表示层，综合参考以前介绍
</code></pre></li>
<li><p>基于同一工作空间静态库实现WLSOO模式</p>

<ol>
<li>工作空间是多个工程的集合</li>
<li><p>lib Project</p>

<pre><code>2. lib添加h文件的配置，Editor-&gt;Add Build Phase-&gt;Add Headers Build Phase
3. Add + 选择h文件
4. 拖拽h文件到Public
</code></pre></li>
<li><p>User Project add Lib</p>

<pre><code>5. lib的使用，Targets-&gt;Name-&gt;Build Phases-&gt;Link Binary With Libraries
6. Add + 选择lib文件
</code></pre></li>
<li><p>User Project Build Setting</p>

<pre><code>7. 头文件搜索设置，Targets-&gt;Name-&gt;Build Settings-&gt;Search Paths
8. 双击User Header Search Paths
9. 加入$(BUILT_PRODUCTS_DIR)产品发布目录,选择recursive递归添加目录路径
</code></pre></li>
<li><p>lib需要给使用者提供.a与.h文件</p></li>
<li><p>如果提示“找不到某些头文件”请检测配置并多次Clean再Build</p></li>
</ol></li>
<li><p>基于同一工作空间框架实现WFOOO模式</p>

<ol>
<li><p>Framework Project</p>

<pre><code>2. 框架添加h文件的配置，Editor-&gt;Add Build Phase-&gt;Add Headers Build Phase
3. Add + 选择h文件
4. 拖拽h文件到Public
</code></pre></li>
<li><p>User Project add 框架</p>

<pre><code>1. lib的使用，Targets-&gt;Name-&gt;Build Phases-&gt;Link Binary With Libraries
2. Add + 选择Framework文件
</code></pre></li>
<li><p>设置保护伞头文件</p>

<pre><code>1. 创建框架工程时默认生成的
2. 命名规则&lt;框架/h File&gt;
</code></pre></li>
<li><p>User Project Build Setting</p>

<pre><code>1. 头文件搜索设置，Targets-&gt;Name-&gt;Build Settings-&gt;Search Paths
2. 双击User Header Search Paths
3. 加入$(BUILT_PRODUCTS_DIR)产品发布目录,选择recursive递归添加目录路径            4. $(LOCAL_LIBRARY_DIR)/Frameworks
5. $(USER_LIBRARY_DIR)/Frameworks
6. @executable_path/../Frameworks
</code></pre></li>
</ol></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-04-22T14:16:05+08:00" itemprop="datePublished">2017/4/22</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14928417654374.html" itemprop="url">
		第十章iOS常用设计模式</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li><p>单例模式SingleTon</p>

<ol>
<li><p>问题提出</p>

<pre><code>1. 只需要某个类的一个实例
2. 实现资源共享与状态保持
</code></pre></li>
<li><p>Objc 实现原理</p>

<pre><code>1. 一般会封装一个静态属性，并提供静态实例的创建方法
2. m文件定义私有静态变量 static来修饰
3. GCD函数dispatch_once，整个程序生命周期中只执行一次代码块，并且县城同步
4. static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
    &lt;#code to be executed once#&gt;
    });
</code></pre></li>
<li><p>Swift 实现原理</p>

<pre><code>1. Class SingleTon {
    static let sharedInstance = SingleTon()
    }
2. Class Singleton {
    static let sharedInstance:SingleTon = SingleTon{
    let instance = Sington()
    return instance 
    }         
</code></pre></li>
<li><p>应用案例</p>

<ol>
<li><p>UIApplication</p>

<pre><code>1. sharedApplication 方法，创建与获取UIApplication的实例
2. idleTimerDisable 属性，空闲时间禁止锁定屏幕
3. openURL，打开内置的iOS应用，包括打开浏览器，谷歌地图，拨打电话，短信与邮件
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;tel://10086&quot;] options:nil completionHandler:nil];
4. sms:10086
</code></pre></li>
<li><p>NSUserDefaults</p>

<pre><code>1. standardUserDefaults ,应用设置项目
</code></pre></li>
<li><p>NSNoticationCenter</p>

<pre><code>1. defaultCenter，观察者模式通知机制
</code></pre></li>
<li><p>NSFileManager</p>

<pre><code>1. defaultManager访问文件系统的通用操作，还可以管理储存在iCloud上的数据
</code></pre></li>
<li><p>NSBundle</p>

<pre><code>1. mainBundle，加载可执行代码，定位资源文件，资源本地化，访问文件系统
</code></pre></li>
</ol></li>
</ol></li>
<li><p>委托模式</p>

<ol>
<li><p>问题提出</p>

<pre><code>1. 生命周期与UIApplication（god Class）
2. UIApplication role1 : 框架类角色，通用，重复使用
3. UIApplication role1 : 应用类角色，常被设计为协议即Java中的接口
4. UIApplication类不直接依赖于AppDelegate类，而是依赖于UIApplicationDelegate
5. AppDelegate是UIApplicationDelegate的委托类
6. 委托是为了降低一个对象的复杂度与耦合度，使其具有通用性，将一些处理放在委托对象中编程
7. 通用类UIApplication因为其通用性，成为了框架类，框架类保持委托对象的指针，并在特定时刻向委托对象发送消息
8. 消息可以是通知委托对象处理一些事情，也可以是对委托对象进行控制
9. Delegate 的实例一般使用Weak进行修饰，防止强引用循环引起内存泄漏
</code></pre></li>
<li><p>实现原理     </p>

<pre><code>1. 通用类(委托人)框架提供==&gt;委托协议Protocel&lt;--委托对象
2. 框架保存委托对象的引用delegate，一般使用weak弱引用
3. 委托对象中在委托使用时一定要指明，通用类.delegate=self
4. 也可以通过storyBoard中delegate的连线来进行委托
</code></pre></li>
<li><p>应用案例UITextFieldDelegate</p>

<pre><code>1. 委托主要负责响应控件事件或控制其他对象
2. Delegate方法的分类，消息的发送，UITextField与Delegate之间的交互
3. Delegate消息命名的约束，委托人开头+(Should/Will/Did)
4. Should -&gt; Return Bool, Will -&gt; Void, Did-&gt;Void
5. 除了委托协议Delegate还有数据源协议DataSource
6. 委托对象主要对控件对象的事件和状态变化做出响应
7. 数据源对象是为控件对象提供数据
</code></pre></li>
</ol></li>
<li><p>观察者模式</p>

<ol>
<li><p>问题提出</p>

<pre><code>1. 观察者模式(Observer),也叫作发布订阅模式(Publish/Subscribe)
2. 观察者模式是MVC(Modal-View-Controller)模式的重要组成部分
3. 气象局 ===&gt;移动运营商短信中心&lt;------&gt;手机用户
4. 一个对象状态的改变会连带影响其他很多对象的状态发生改变，对象之间匿名通信，则考虑观察者模式
</code></pre></li>
<li><p>实现原理</p>

<pre><code>1. 四个主题，Subject，Observer，ConcreteObserver，ConcreteSubject
2. 抽象主题 Subject，观察者集合器 Protocel，attach，detach，notifyObserver
3. 抽象观察者，Observer，Protocel，update
4. 具体观察者，ConcreteObserver，Observer协议的具体实现
5. 具体主题，ConcreteObject，Subject协议的具体实现
6. 引入Subject与Observer，提高了系统可复用性，降低了耦合度
</code></pre></li>
<li><p>Notification与KVO机制</p>

<ol>
<li>Cocoa Touch的框架，关于观察者模式的具体使用，有两个，通知与KVO</li>
<li><p>通知机制</p>

<pre><code>1. Notification，“一对多”的对象之间的通信 
2. Delegate，“一对一”的对象之间的通信
3. 广播通知，broadcast notification，应用中对象之间发送消息
4. 本地通知，local notification，本地iOS发出，是用户提示
5. 推送通知，push notification ，第三方-&gt;Apple Center-&gt;iOS应用，警告框，声音，震动，应用图标显示数字
6. 广播通知，通知中心 [NSNoticationCenter defaultCenter]
7. 通知中心，注册通知，addObserver:name
8. 通知中心，注销通知，removeObserver:name
</code></pre></li>
<li><p>CODE</p>

<pre><code>1. [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(registerAdd:) name:REGISTER_ADD_NOTIFICATION object:nil];
2. -(void)registerAdd:(NSNotification*) notify
3. [[NSNotificationCenter defaultCenter] removeObserver:self];
4. [[NSNotificationCenter defaultCenter] postNotificationName:REGISTER_ADD_NOTIFICATION object:nil userInfo:userDic];
NSLog(@&quot;This is the end&quot;);}]
</code></pre></li>
<li><p>KVO 机制</p>

<pre><code>1. 不是通过通知中心通知所有观察者，而是属性变化时直接发送消息给观察者对象
2. 注册观察者：[self addObserver:self.appStatusObserver forKeyPath:@&quot;appStatus&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:@&quot;Completed&quot;];
3. 观察者重写：-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context
4. 继承NSObject或实现NSKeyValueObserving协议
</code></pre></li>
</ol></li>
</ol></li>
<li><p>MVC模式</p>

<ol>
<li><p>MVC模式概述</p>

<pre><code>    1. MVC模式是一种复合设计模式，由观察者模式(Observer),策略模式(Strategy),和合成模式(Composite)等组成
    2. Model，模型，保存应用数据状态。回应视图对状态的查询，处理应用业务逻辑，完成应用功能，将状态的变化通知视图
    3. View，视图，为用户展示信息并提供接口，用户通过视图向控制器发出动作请求，然后再向模型发出状态查询申请，模型状态的变化会通知给视图
    4. Controller，控制器，接受用户请求，并更新模型，控制器还会更新选择的视图。控制器是模型与视图的媒介，可以降低Model与Controller的耦合
    5. View&lt;-------&gt;    Controller&lt;------&gt;Model(Content,Context,Data)
</code></pre></li>
<li><p>Cocoa Touch中的MVC模式</p>

<pre><code>    1. View==&gt;UIView==&gt;Code create &amp;&amp; StoryBoard
    2. Model==&gt;NSObject==&gt;Data
    3. Controller==&gt;UIViewController
    4. 将视图定义为IBOutlet与IBAction
    5. model就是数据，有时候未必需要自己创建一个model类
</code></pre></li>
</ol></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-04-22T14:13:37+08:00" itemprop="datePublished">2017/4/22</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14928416177561.html" itemprop="url">
		第九章iPad应用开发</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			

			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-04-19T10:54:14+08:00" itemprop="datePublished">2017/4/19</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14925704543702.html" itemprop="url">
		导航模式</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li>标签式导航：最常用、最不易出错，请第一时间考虑它</li>
<li>抽屉式导航：如果你的信息层级繁多，可以考虑将辅助类内容放在抽屉中</li>
<li>列表式导航：作为辅助导航来展示二级甚至更深层级的内容，每个APP必不可少，但请注意数量与分类</li>
<li>平铺式导航：如果你的内容是随意浏览，无需来回跳转的，可以考虑它。</li>
<li>宫格式导航：不建议在APP中作为主导航使用，如果非使用不可，请增加跳转的关联性</li>
<li>悬浮式导航：更适应大屏的导航模式，不妨试一试，但注意不要让它遮挡住某些页面的操作</li>
<li>presentViewController   Modal  dismissViewControllerAnimated</li>
<li>pushViewController Navigation  popViewControllerAnimated</li>
<li>prepareForSegue  SegueIdentifier  destinationViewController</li>
</ol>

<h2 id="toc_0">BarButtonItem</h2>

<pre><code>UIBarButtonItem *btnItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;Root&quot;
        style:UIBarButtonItemStylePlain
        target:self
        action:@selector(popToRootView)];
self.navigationItem.rightBarButtonItem = btnItem;
</code></pre>

<h2 id="toc_1">WKWebView</h2>

<ol>
<li><p>initial</p>

<pre><code>`#import &lt;WebKit/WebKit.h&gt;
@interface DetailViewController ()&lt;WKNavigationDelegate&gt;
@property(strong,nonatomic)WKWebView *webView;  ` 
</code></pre></li>
<li><p>Implement</p>

<pre><code>self.webView = [[WKWebView alloc]initWithFrame:self.view.frame];
[self.view addSubview:self.webView];
self.webView.navigationDelegate = self;
NSURL *url = [NSURL URLWithString:self.url];
NSURLRequest *urlRequest = [NSURLRequest requestWithURL:url];
[self.webView loadRequest:urlRequest];
</code></pre></li>
<li><p>Info file (Http)</p>

<pre><code>App Transport Security Settings      Dictionary
Allow Arbitrary Loads   Boolean True
</code></pre></li>
</ol>

<h2 id="toc_2">Code App</h2>

<ol>
<li><p>App Delegate</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
// Override point for customization after application launch.
self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen] bounds]];
[self.window makeKeyAndVisible];
self.window.backgroundColor = [UIColor whiteColor];

ViewController *viewController = [[ViewController alloc]init];
UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:viewController];
self.window.rootViewController = navigationController;    
return YES;
}
</code></pre>

<h2 id="toc_3">Controller Reference</h2></li>
<li><p>Init</p>

<pre><code>[[RegisterViewController alloc]init];       
</code></pre></li>
<li><p>Init with Xib</p>

<pre><code>[[RegisterViewController alloc]initWithNibName:@&quot;main&quot; bundle:nil];
</code></pre></li>
<li><p>segue</p>

<pre><code>-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
    {
    if ([segue.identifier isEqualToString:@&quot;ShowSelectedProvince&quot;]) {
    NSIndexPath * indexPath = [self.tableView indexPathForSelectedRow];
    CitiesTableViewController *citiesViewController = segue.destinationViewController;
    NSString *selectName = [self.listArray objectAtIndex:indexPath.row];
    citiesViewController.listData = [self.dictData objectForKey:selectName];
    citiesViewController.title = selectName;
    }
    }
</code></pre></li>
<li><p>storyBoard</p>

<pre><code>self.navigation = [self.storyboard instantiateViewControllerWithIdentifier:@&quot;navigation&quot;];
</code></pre></li>
</ol>

<h2 id="toc_4">library/Framework Search</h2>

<ol>
<li><p>User Project Build Setting</p>

<pre><code>    1. 头文件搜索设置，Targets-&gt;Name-&gt;Build Settings-&gt;Search Paths
    2. 双击User Header Search Paths
    3. 加入$(BUILT_PRODUCTS_DIR)产品发布目录,选择recursive递归添加目录路径            4. $(LOCAL_LIBRARY_DIR)/Frameworks
    5. $(USER_LIBRARY_DIR)/Frameworks
    6. @executable_path/../Frameworks
</code></pre></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-04-10T11:11:18+08:00" itemprop="datePublished">2017/4/10</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14917938784200.html" itemprop="url">
		第八章 视图控制器与导航模式</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li><p>概述</p>

<ol>
<li><p>视图控制器种类</p>

<pre><code>1. UIViewController ，自定义视图控制器
2. UINavigationController，导航与UITableViewController结合使用
3. UITabBarController，树标签导航
4. UIPageViewController，电子书导航风格
5. UISplitViewController，iPad设计，屏幕分为几块
6. UIPopoverController，iPad，气泡风格视图控制器
</code></pre></li>
<li><p>导航模式</p>

<pre><code>1. 平铺导航模式，内容都放在主屏幕上，通过左右上下来查看，采用分屏或分页控制器，天气
2. 标签导航模式，内容分为几个模块，通过标签控制器来管理模块显示与切换，闹钟
3. 树形结构导航模式，内容是有层次的，表视图控制器，邮件
</code></pre></li>
</ol></li>
<li><p>模态视图“presentViewController”</p>

<ul>
<li><p>简介</p>

<pre><code>    1. 模态视图从屏幕下方弹出，且完成后关闭，并返回。
    2. 模态视图用于处理次级任务，具有必须响应处理的意思
    3. 主视图控制器与模态视图控制器是&quot;父子&quot;的关系
    4. 实现方式有两种，1代码实现，2 IB的segue实现
</code></pre></li>
<li><p>IB 实现Segue</p>

<pre><code>    1. Embeded In Navigation Controller
    2. 拖拽事件到 Navigation Controller
    3. 选择Present Modally
</code></pre></li>
<li><p>Code 实现</p>

<pre><code>    1. 创建NavigationController，并设置RootViewController
    2. 展现视图“[self presentViewController:navigationController animated:TRUE completion:^”
</code></pre></li>
<li><p>视图返回</p>

<pre><code>    [self dismissViewControllerAnimated:YES completion:^{
</code></pre></li>
<li><p>注意要点</p>

<pre><code>    1. 展示视图，不仅适用于NavigationController，而且适用于一般的ViewController
    2. 如果一个ViewController已经作为一个NAvigationController的rootViewController，则不可展示，因为该ViewController已经处于Active状态
</code></pre></li>
</ul></li>
<li><p>平铺导航</p>

<ol>
<li><p>应用场景</p>

<pre><code>1. 用于简单的平铺化信息浏览，信息没有层次关系，没有从属关系
2. 天气，电子书
</code></pre></li>
<li><p>基于分屏导航   PageControlNavigation</p>

<pre><code>1. 分屏控件 UIPageControl
2. 屏幕滚动视图 UIScrollView
3. 屏幕应该小于20
4. 图片控件，UIImageView
5. ScrollView的contentSize与contentOffset
6. ScrollView的代理方法，“scrollViewDidScroll”
7. PageControl的value change事件“changePage”
8.  [UIView animateWithDuration:0.3f animations:^{
NSInteger whichPage = self.pageControl.currentPage;
self.scrollView.contentOffset = CGPointMake(self.view.frame.size.width*whichPage, 0);
NSLog(@&quot;the action is doing&quot;);
}];
</code></pre></li>
<li><p>基于电子书导航</p>

<ol>
<li><p>UIPageViewController</p>

<pre><code>1. 需要实现UIPageViewControllerDataSource与UIPageViewControllerDelegate
2. UIPageViewController没有对应的视图类
3. pageViewController:viewControllerBeforeViewController
4. pageViewController:viewControllerAfterViewController
5. pageViewController:spineLocationForInterfaceOrientation
6. Attribute: doubleSided,Spine Location(Min,Max,Mid)
7. pageViewController:didFinishAnimating:previousViewControllers:transitionCompleted:
</code></pre></li>
<li><p>PageNavigation</p>

<ol>
<li>定义enum类型与int directionFoward用于记录翻页方向，前翻与后翻</li>
<li>定义int 类型 pageIndex用于记录</li>
<li>声明两个变量，PageViewController与NSArray(viewControllers)</li>
<li>PageViewController实例化，设置代理，设置首页，并加入到View中</li>
<li><p>两个DataSource与两个Delegate方法的实现</p>

<pre><code>“-(void)pageViewController:(UIPageViewController *)pageViewController didFinishAnimating:(BOOL)finished previousViewControllers:(NSArray&lt;UIViewController *&gt; *)previousViewControllers transitionCompleted:(BOOL)completed” 
</code></pre></li>
</ol></li>
</ol></li>
</ol></li>
<li><p>Tab标签导航</p>

<ol>
<li><p>使用场景</p>

<pre><code>    1. 标签栏位于屏幕下方，占49点屏幕空间，可以隐藏
    2. 一般标签栏中标签不超过5个，超过则为&quot;更多&quot;
    3. 小组内部的数据有一定的关联关系，是用标签导航
    4. 每个标签代表一个功能模块，各个模块之间相互独立
</code></pre></li>
<li><p>实例：TabNavigation</p>

<pre><code>    1. 创建TabViewController
    2. 创建其他的几个ViewController
    3. Control Tab拖拽segue到ViewController选择viewControllers
</code></pre></li>
<li><p>代码实现 AppDelegate</p>

<pre><code>    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen] bounds]];
    [self.window makeKeyAndVisible];
    self.window.backgroundColor = [UIColor whiteColor];
    UITabBarController *tabBarController= [[UITabBarController alloc]init];
    self.window.rootViewController = tabBarController;
    HeiViewController *heiController = [[HeiViewController alloc]initWithNibName:nil bundle:nil];
    JiViewController *jiController = [[JiViewController alloc]initWithNibName:nil bundle:nil];
    LiaoViewController *liaoController = [[LiaoViewController alloc ]initWithNibName:nil bundle:nil];
    tabBarController.viewControllers = @[heiController,jiController,liaoController];
     return YES;
     }
</code></pre></li>
</ol></li>
<li><p>树形结构导航</p>

<ol>
<li><p>应用场景“从属”</p>

<pre><code>1. 树形结构导航模式主要构建有&quot;从属关系&quot;的导航
2. 这种导航采用分层组织信息的方式，组建iOS效率型应用程序。
3. 效率性应用程序具有组织和操作具体信息的功能，通常用于完成比较重要的任务，通常分层组织信息，相册是典型的例子
4. 第一个界面是根视图，第二个界面是二级视图，第三个界面是三级视图
5. 一级视图的导航栏可以添加左右按钮，二级视图或更高级视图的左按钮是导航控制器自己添加的
</code></pre></li>
<li><p>实例TreeNavigation</p>

<pre><code>1. 删除ViewController，添加Navigation Controller，并设置attribute inspector，is InitialViewController
2. 导航控制器的根视图视图控制器为UITableViewController
3. 树形结构导航的window根视图导航器是导航控制器UINavigationController
4. storyBoard专用的Navigation-&gt;prepareForSegue:sender:

-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
if ([segue.identifier isEqualToString:@&quot;ShowSelectedProvince&quot;]) {
NSIndexPath * indexPath = [self.tableView indexPathForSelectedRow];
CitiesTableViewController *citiesViewController = segue.destinationViewController;
NSString *selectName = [self.listArray objectAtIndex:indexPath.row];
citiesViewController.listData = [self.dictData objectForKey:selectName];
citiesViewController.title = selectName;
}
}
5. 除了segue，还可以使用navigationController的Push与Pop方法
[self.navigationController pushViewController:detailViewController animated:YES];
6. NavigationController 将要管理的视图控制器放入他的栈中，处于栈顶的视图控制器负责显示当前的视图，如果要显示下一级视图就需要将下一级视图控制器压栈Push，要返回上级视图控制器，就要使用出栈方法Pop
7. popToViewController:animated:
8. popToRootViewControllerAnimated
9. popViewControllerAnimated
10. pushViewController:animated:
</code></pre></li>
</ol></li>
<li><p>组合使用导航模式</p>

<ol>
<li><p>应用场景</p>

<pre><code>1. 标签导航用于省间信息切换
2. 树形结构用于省内信息显示
3. 二级视图的右边按钮可以添加城市信息
</code></pre></li>
<li><p>实例 CombNavigation</p>

<ol>
<li><p>标签控制器</p>

<pre><code>1. 创建Single View Application
2. Main Story删除ViewController
3. 添加TabViewController
4. 删除Item1 与Item2
5. TabViewController设置属性Inspector为Initial View Controller
</code></pre></li>
<li><p>一级视图控制器</p>

<pre><code>1. 添加Navigation Controller到Story界面
2. 按住Control键，TabViewController中拖拽鼠标到Navigation
3. 选择Segue中Relationship Segue中的view controllers
</code></pre></li>
<li><p>二级视图</p>

<pre><code>1. 添加ViewController到StoryBoard
2. 按住Control键，RootViewController中Cell拖拽鼠标到ViewController
3. 选择Segue中Selection Segue中的Show
4. 选中Segue,打开属性Inspector，Identifier 填写ShowDetail
5. 添加Navigation Item到ViewController，
6. 设置Navigation Item的Title为“Detail View Controller”
6. 添加Button Item到Navigation Item
7. 设置Button Item的System Item为Add
</code></pre></li>
<li><p>模态视图控制器</p>

<pre><code>1. 添加ViewController 
2. Editor,Emdebbed Navigation  to ViewController
3. 按住Control键，鼠标拖拽二级视图Add到Navigation Controller
4. 在弹出的对话框中选择，Present Modally
5. 设置Navigation Item的Title为Modal View
6. 添加Button item “Cancel”“Save”到Navigation Item
7. 添加TextView到ViewController
</code></pre></li>
<li><p>设置标签栏的内容</p>

<pre><code>1. 按住Control键，从TabViewController拖拽到NavigationController
2. 选择segue，controllers
3. 点击Navigation的Tab标签，设置Inspector的Title与image
</code></pre></li>
<li><p>代码添加</p>

<pre><code>1. 需要三个视图控制器文件，ViewController，DetailViewController与ModalViewController
2. ViewController父类TableViewController
3. Detail与Modal的父类为ViewController
4. TableViewController的ParentViewController为NavigationController
5. add Content and navigation
6. presentViewController
7. dismissViewControllerAnimated
8. prepareForSegue
</code></pre></li>
<li><p>代码实现</p>

<ol>
<li><p>AppDelegate 初始化Window与TabController</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
// Override point for customization after application launch.
self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen] bounds]];
[self.window makeKeyAndVisible];

UITabBarController *tabController = [[UITabBarController alloc]init];
self.window.rootViewController = tabController;

ViewController *viewController1 = [[ViewController alloc]init];
UINavigationController *navigationController1 = [[UINavigationController alloc]initWithRootViewController:viewController1];
navigationController1.tabBarItem.title = @&quot;黑龙江省&quot;;
navigationController1.tabBarItem.image = [UIImage imageNamed:@&quot;Hei&quot;]；
tabController.viewControllers = [NSArray arrayWithObjects:navigationController1,navigationController2,navigationController3, nil];
return YES;
} 
</code></pre></li>
<li><p>一级视图ViewController实现select跳转</p>

<pre><code>-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
DetailViewController * detailController = [[DetailViewController alloc]init];
NSUInteger selectedRow = indexPath.row;
detailController.url = [[self.listArray objectAtIndex:selectedRow] objectForKey:@&quot;url&quot;];
detailController.title = [[self.listArray objectAtIndex:selectedRow] objectForKey:@&quot;name&quot;];
[self.navigationController pushViewController:detailController animated:YES];
NSLog(@&quot;the url is %@&quot;,detailController.url);
}
</code></pre></li>
<li><p>DetailController界面布局添加</p>

<pre><code>- (void)viewDidLoad {
[super viewDidLoad];
UIBarButtonItem *barButton = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemAdd target:self action:@selector(add:)];
self.navigationItem.rightBarButtonItem = barButton;

self.webView = [[WKWebView alloc]initWithFrame:[self.view bounds]];
[self.view addSubview:self.webView];
self.webView.navigationDelegate = self;
NSURL *url = [NSURL URLWithString:self.url];
NSURLRequest * request = [NSURLRequest requestWithURL:url];
[self.webView loadRequest:request];
}

-(void)add:(id)sender
{
ModalViewController *modalController = [[ModalViewController alloc]init];
UINavigationController *navigationController = [[UINavigationController alloc]initWithRootViewController:modalController];
[self presentViewController:navigationController animated:YES completion:^{
NSLog(@&quot;The modal View Controller is present&quot;);
}];
}
</code></pre></li>
<li><p>ModalController布局</p>

<pre><code>- (void)viewDidLoad {
[super viewDidLoad];
UIBarButtonItem* cancelItem = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemCancel target:self action:@selector(clickCancel:)];
UIBarButtonItem* saveItem = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemSave target:self action:nil];
self.navigationItem.leftBarButtonItem = cancelItem;
self.navigationItem.rightBarButtonItem = saveItem;UITextView 
*textView = [[UITextView alloc]initWithFrame:[self.view bounds]];
textView.text = @&quot;This is the madal View Content&quot;;
[self.view addSubview:textView];
}
-(void)clickCancel:(id)sender
{
[self dismissViewControllerAnimated:YES completion:^{
NSLog(@&quot; cancel the modal View, go to back View&quot;);
}];
}
</code></pre></li>
</ol></li>
</ol></li>
</ol></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-04-07T10:54:42+08:00" itemprop="datePublished">2017/4/7</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14915336829264.html" itemprop="url">
		第七章 界面布局与屏幕适配</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li><p>界面布局概述</p>

<pre><code>1. 为了适配多种IOS 设备屏幕，iOS8推出了 Auto Layout的Size Class技术
2. 不应该只是简单的iPhone界面放大，而是需要重新布局
3. 屏幕布局中有，状态栏，标签栏，导航栏，工具栏以及内容视图部分
4. UIStatusBar          height 20
5. UINavigationBar  height 44
6. UIView
7. UITabBar             height 49
</code></pre></li>
<li><p>界面布局设计模式</p>

<ol>
<li><p>表单布局模式</p>

<pre><code>1. 表单布局，例如登陆界面与注册界面可以采用静态表视图实现
</code></pre></li>
<li><p>列表布局模式</p>

<pre><code>1. 需要展示大量数据时，列表布局使用动态表视图
2. 需要实现delegate与datasource相关方法
</code></pre></li>
<li><p>网格布局模式</p>

<pre><code>1. 可以实现多列，使用集合视图实现
</code></pre></li>
<li><p>堆视图 StackView</p>

<pre><code>1. 可以实现管理垂直方向与水平方向排列的布局
</code></pre></li>
</ol></li>
<li><p>传统布局技术</p>

<pre><code>1. MainStoryBoard，File Inspector, 取消 Use Auto Layout 和 Use Size Classes
2. Button ，Size Inspector， View Autoresizing,虚线 相对距离，实线 绝对距离
3. 屏幕旋转   Command + 左右箭头
4. 传统布局，只能设置，上下左右边距，不能设置屏幕中视图之间的距离
</code></pre></li>
<li><p>Auto Layout 布局技术</p>

<ol>
<li><p>Auto Layout</p>

<pre><code>1. 为空间布局定义了一套约束(constraint),定义了视图之间的关系
2. AutoLayout 可以通过IB 或代码实现
3. 通过代码构建界面，不推荐使用Auto Layout，而是自己根据屏幕大小动态计算视图位置
</code></pre></li>
<li><p>IB 管理Auto Layout</p>

<pre><code>1. IB 针对Auto Layout提供了一些操作按钮
2. Stack  ，将视图对象添加到堆视图StackView中
3. Align    ， 创建对齐约束，如使视图在容器中
4. Pin  ，创建距离和位置的相关约束，如高度，相对其他试图的距离
5. 解决布局问题 ，解决布局中的问题
</code></pre></li>
<li><p>实例 AutoLayoutSAmple</p>

<pre><code>1. 水平居中，Align ， Horizontally in Container，Add Constraint
2. 上边距，下边距，左右边距绝对约束，Pin ， 点击上边虚线，变为实线，Add Constraint
3. 两个控件对齐操作，Shift 选中两个， Aligh， Top Edges，Add Constraint
4. 属性检测器，Attribute Inspector 的约束查看与编辑
</code></pre></li>
</ol></li>
<li><p>Stack View</p>

<ol>
<li><p>StackView 与布局</p>

<pre><code>1. 堆视图是iOS9中一种新的容器视图，类为UIStackView
2. Container 视图都可以用于界面布局
3. Stack View可以使构建复杂界面布局变得简单
4. Stack View可以管理两个方向的界面布局
5. Stack View还可以实现视图的嵌套
</code></pre></li>
<li><p>实例StackViewSample</p>

<pre><code>1. In UIView , add vertical stack
2. in Vertical Stack ,add Horizontal stack
3. in Vertical Stack ,add button1 upper Horizontal 
4. in Horizontal Stack , add button2 button3
5. Setting  Stack Attribute: Spacing -Between View
6. Add Constraints to the Stack View
</code></pre></li>
</ol></li>
<li><p>iOS 屏幕多样性</p>

<ol>
<li><p>iOS 屏幕</p>

<pre><code>1. iPhone6/6s Plus  5.5  1920*1080   Retina HD
2. iPhone6/6s       4.7  1334*750    Retina HD
3. iPhone5/5s/5c        4    1136*640    Retina
4. iphone4s             3.5  960*640     Retina
5. iPad Pro             12.9 2732*2048   Retina
6. iPad Air             9.7  2048*1536   Retina
7. iPad Mini            7.9  2048*1536   Retina
</code></pre></li>
<li><p>iOS 三种分辨率</p>

<pre><code>1. 资源分辨率 ， 资源图片大小，单位像素
2. 设计分辨率 ， 逻辑上的屏幕大小，单位点
3. 屏幕分辨率     ， 以像素为单位的屏幕大小
</code></pre></li>
<li><p>获取iOS 设备屏幕信息</p>

<pre><code>1. [UIDevice currentDevice].userInterfaceIdiom
2. CGSize iOSDeviceScreenSize = [UIScreen mainScreen].bounds.size       
</code></pre></li>
</ol></li>
<li><p>Size Class 与iOS 多屏幕适配</p>

<ol>
<li><p>简介</p>

<pre><code>1. AutoLayout 技术解决界面差距小的情况
2. Size Class 为新的屏幕适配技术，建立在AutoLayout 之上
3. Size Class 不能通过Code 进行管理，只能通过IB使用
</code></pre></li>
<li><p>IB 中使用Size Class</p>

<pre><code>1.  可以在IB 中File Inspector配置使用Auto Layout与Size Class
2. Size Class的面板在&quot;wAny hAny&quot;点击后呈现
3. Size Class面板是一个九宫格
</code></pre></li>
<li><p>Size Class 九宫格</p>

<pre><code>1. Size Class 九宫格有9种不同的布局
2. Width 与Height 两个布局方向，三个类别，Compact，Any，Regular
3. 坐标原点左上角  
4. wCompact , hCompact
5. wAny , hCompact
6. wRegular , hCompact
7. wCompact , hAny
8. wAny , hAny
9. wRegular , hAny
10. wCompact , hRegular
11. wAny , hRegular
12. wRegualar , hRegular
</code></pre></li>
<li><p>实例，SizeClassSample</p>

<pre><code>1. iPhone 竖屏 wCompact , hRegular
2. 添加AutoLayout
3. 打开辅助编辑器Assistant Editor，Preview-&gt;Main.storyBoard
4. 左下角+添加新的设备，也可以删除设备&quot;Delete&quot;键，也可以旋转横屏
5. 有问题会出现，红色或黄色图标，可以弹出问题对话框

    &gt;1. Update Frame
    &gt;2. Update Constraints
    &gt;3. Reset to Suggested Constraints
    &gt;4. Apply to all views in container
    &gt;   Fix Misplacement
6. 布局问题解决:Resolve Auto Layout issues-&gt;Constraints
</code></pre></li>
</ol></li>
<li><p>资源目录与图片资源适配</p>

<ol>
<li><p>Assets.xcassets</p>

<pre><code>1. 默认项目,AppIcon应用图标
2. add + New Image Set &quot;background&quot;
3. drag UIImageView, set attribute &quot;image&quot; to &quot;background&quot;
</code></pre></li>
</ol></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-30T13:42:17+08:00" itemprop="datePublished">2017/3/30</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14908525378266.html" itemprop="url">
		Manual StoryBoard Load</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li>In delegate file ,add the application launching Action</li>
<li>Every Application have its main UIScreen</li>
<li>First we have to initial a Windowfor the APP with main Screen Bounds:<code>self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen]bounds]];</code></li>
<li>Second the Window have its Rootview and we have to add the  related RootViewController:<code>self.window.rootViewController = [[ViewController alloc]init]</code></li>
<li>we need set the back ground color of the Window,<code>self.window.backgroundColor = [UIColor whiteColor]</code></li>
<li>Must make window visible :<code>[self.window makeKeyAndVisible]</code></li>
</ol>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
  
    self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen]bounds]];
    self.window.rootViewController = [[ViewController alloc]init];
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];
    
    return YES;
}

</code></pre>

<ul>
<li>Navigation Controller </li>
</ul>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen] bounds]];
    [self.window makeKeyAndVisible];
    self.window.backgroundColor = [UIColor whiteColor];
    
    ViewController *viewController = [[ViewController alloc]init];
    UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:viewController];
    self.window.rootViewController = navigationController;    
    return YES;
}
</code></pre>

<h3 id="toc_0">从A界面打开B界面</h3>

<ul>
<li>(void)presentViewController:(UIViewController *)viewControllerToPresent animated:(BOOL)flag completion:(void (<sup>)(void))completioncompletion:(void</sup> (<sup>)(void))completion</sup> 在B界面的viewDidAppear()调用后执行</li>
</ul>

<p>pushViewController<br/>
popViewControllerAnimated </p>

<h3 id="toc_1">关闭当前界面（B界面），返回之前的界面（A界面）</h3>

<ul>
<li>(void)dismissViewControllerAnimated:(BOOL)flag completion:(void (<sup>)(void))completioncompletion:(void</sup> (<sup>)(void))completion</sup> 在A界面的viewDidAppear()调用后执行</li>
</ul>

<h3 id="toc_2">Navigation Push ViewController</h3>

<p>[self.navigationController pushViewController:detailViewController animated:YES];</p>

<h3 id="toc_3">Navigation Segue Drag</h3>

<ul>
<li><p>(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {<br/>
// Get the new view controller using [segue destinationViewController].<br/>
// Pass the selected object to the new view controller.<br/>
if ([segue.identifier isEqualToString:@<q>ShowSelectedCity</q>]) {</p>

<p>DetailViewController *detailViewController = segue.destinationViewController;</p>

<pre><code>NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
</code></pre>

<p>detailViewController.url = [[self.listData objectAtIndex:indexPath.row] objectForKey:@<q>url</q>];<br/>
    detailViewController.title = [[self.listData objectAtIndex:indexPath.row] objectForKey:@<q>name</q>];<br/>
}<br/>
}</p></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-30T09:19:52+08:00" itemprop="datePublished">2017/3/30</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14908367919969.html" itemprop="url">
		第六章:表视图</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li><p>概述</p>

<ol>
<li>表视图是使用最频繁的视图，是展示数据最方便的方式，如通讯录，频道列表等</li>
<li>表视图的功能，分组，分节和索引可以使所展示的数据更规整，更有条理</li>
<li>表视图，包括表头视图(table header view)，表脚视图(table footer view)，单元格(Cell)与节 &lt;节头，节尾&gt;(Section)</li>
<li><p>表视图的相关类</p>

<pre><code>1. UITableView继承自UIScrollView
2. 有两个协议，UITableViewDelegate，UITableViewDataSource
3. 包括的类有UITableViewCell，UITableViewController，UITableViewHeaderFooterView
</code></pre></li>
<li><p>表视图分类</p>

<pre><code>1. 普通表视图，用于单元格数目未知的动态表
2. 分组表视图，用于静态表，进行控件界面布局，还包括索引列，选择列和搜索栏等，另外有表头，表脚的按钮与标识
</code></pre></li>
<li><p>单元格的组成与样式</p>

<ol>
<li>table的单元格由图标，标题（主标题，副标题）与扩展视图组成</li>
<li>单元格有很多样式，可以有选择的设置，扩展视图在UITableViewCallAccessoryType 中定义</li>
<li>单元格的样式是在枚举类型UITableViewCellType中定义</li>
<li>单元格还可以自定义</li>
</ol></li>
<li><p>TableView在开发过程中也可以使用委托协议与数据源协议，UITableViewDelegate, UITableViewDataSource</p>

<ol>
<li><p>UITableViewDataSource</p>

<pre><code>1. tableView:cellForRowAtIndexPath: UITableViewCell 单元格，Must implement
2. tableView:numberofRowInSection: Int 某个节中的行数
3. tableView:titleForHeaderInSection: String 节头标题
4. tableView:titleForFooterInsection: String 节脚标题
5. numberofSectionsInTableView: Int 节的个数
6. sectionIndexTitleForTableView: id 表视图节索引标题
7. tableView:commitEditingStyle:forRoewAtIndexPath 修改
</code></pre></li>
<li><p>UITableViewDelegate</p>

<pre><code>1. tableView:viewForHeaderInSection: UIView 自定义节头视图 
2. tableView:viewForHeaderInSection: UIView 自定义节脚视图
3. tableView:didEndDisplayingHeaderView:forSection: 节头消失
4. tableView:didEndDisplayingFooterView:forSection: 节脚消失
5. tableView:didDisplayingCell:forRowAtIndexPath: 单元格消失
6. tableView:didSelectRowAtIndeexPath: 选择表视图单元格
7. tableView:editActionsForRowAtIndexPath: id 单元格水平滑动
</code></pre></li>
</ol></li>
</ol></li>
<li><p>简单表视图</p>

<ol>
<li>简单表视图，单元格使用默认样式，有图标和主标题</li>
<li><p>简单示意图</p>

<pre><code>1. 用户(Controller)  ----&gt; 表视图--&gt;实例化，设置数据源与委托
2. 表视图(TableView)   ----&gt;数据源--&gt;dataSource与Delegate方法
3. 整个界面是一个视图，分为根视图为UIView和根视图为UITableView两种方案，对应的根视图控制器也分为，UIViewController与UITableViewController
</code></pre></li>
<li><p>TableSample案例</p>

<ol>
<li>创建SingleViewApplication工程，命名为TableSimple</li>
<li>添加资源图片与列表文件到工程</li>
<li>拖拽视图tableView，设置属性Prototype Cells为1，并设置cell的identifier</li>
<li>获取文件列表DataSource，Array，调用numberofRowInSection返回Array Count</li>
<li><p>重写cellForRowAtIndexPath，获取可重用单元格，并重载该单元格</p>

<pre><code>-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return [self.listTeams count];
 }
 -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
 {
UITableViewCell *tableCell = [tableView dequeueReusableCellWithIdentifier:@&quot;cellIdentifier&quot;];
NSUInteger row = [indexPath row];
NSDictionary *resourceDic = [self.listTeams objectAtIndex:row];
tableCell.textLabel.text = [resourceDic objectForKey:@&quot;name&quot;];
tableCell.imageView.image = [UIImage imageNamed:[resourceDic objectForKey:@&quot;image&quot;]];
tableCell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
return tableCell;
}
</code></pre></li>
<li><p>Code 实现</p>

<ol>
<li><p>add tableView and delegate</p>

<pre><code>    self.tableView = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStylePlain];
    self.tableView.delegate = self;
    self.tableView.dataSource = self;
    [self.view addSubview:self.tableView];
</code></pre></li>
<li><p>create the tableViewCell and reuse it</p>

<pre><code>UITableViewCell *tableCell = [tableView dequeueReusableCellWithIdentifier:@&quot;cellIdentifier&quot;];
if (tableCell == nil) {
tableCell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;cellIdentifier&quot;];
 }
</code></pre></li>
<li><p>Delegate File add View Scene</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
// Override point for customization after application launch;
self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen]bounds]];
self.window.rootViewController = [[ViewController alloc]init];
self.window.backgroundColor = [UIColor whiteColor];
[self.window makeKeyAndVisible];
return YES;
}
</code></pre></li>
</ol></li>
</ol></li>
<li><p>根视图控制器UITableViewController</p>

<ol>
<li>删除原来的UIViewController，拖拽UITableViewController到storyBoard</li>
<li>设置UITableViewController属性 Is Initial View Controller，表示该视图控制器是初始视图控制器</li>
<li>修改ViewController的父类为UITableViewController，并删除已添加的tableView属性</li>
<li>IB中设置TableViewController Scene属性为Class ViewController</li>
<li><p>方便之处</p>

<pre><code>1. 不需要声明实现协议UITableViewDelegate与UITableViewDataSource
2. 不需要新建tableView并分配delegate与DataSource
</code></pre></li>
</ol></li>
</ol></li>
<li><p>自定义表视图单元格</p>

<ol>
<li> 参考上页，创建根视图为继承于UITableViewController的工程</li>
<li> 添加继承于UITableViewCell的类，CustomCell</li>
<li> IB设置该TableViewCell的属性，Class为CustomCell</li>
<li><p>在CustomCell中代码实现添加控件到Cell</p>

<pre><code>-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
{
self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
if (self) {
CGFloat cellWidth = self.frame.size.width;
CGFloat cellHeight = self.frame.size.height;
CGFloat imageWidth = 40;
CGFloat imageHeight = 30;
CGFloat imageRightView = 40;
self.myImageView = [[UIImageView alloc]initWithFrame:CGRectMake(cellWidth-(imageWidth+imageRightView), (cellHeight -imageHeight)/2, imageWidth, imageHeight)];
[self addSubview:self.myImageView];
CGFloat labelWidth = 100;
CGFloat labelHeight = 35;
CGFloat labelLeftView = 120;
self.myLabel = [[UILabel alloc]initWithFrame:CGRectMake( labelLeftView, (cellHeight -labelHeight)/2, labelWidth, labelHeight)];
[self addSubview:self.myLabel];    
}
 return self;
 }
</code></pre></li>
<li><p>设置默认调用该方法实例化Cell</p>

<pre><code>- (void)viewDidLoad {
[super viewDidLoad];
NSBundle *bundle = [NSBundle mainBundle];
NSString* plistPath = [bundle pathForResource:@&quot;team&quot; ofType:@&quot;plist&quot;];
self.listTeams = [[NSArray alloc]initWithContentsOfFile:plistPath];
[self.tableView registerClass:[CustomCell class]  forCellReuseIdentifier:@&quot;cellIdentifier&quot;];
}
</code></pre></li>
</ol></li>
<li><p>添加搜索栏</p>

<ol>
<li>搜索栏控制器<code>UISearController</code>简化了搜索栏的开发，只能通过代码实现</li>
<li><p>搜索栏的样式</p>

<pre><code>1. Search Result Button
2. Bookmarks Button
3. Cancel Button
4. Scope Button
5. PlaceHolder
</code></pre></li>
<li><p>搜索栏是一个比较复杂的控件，具有委托协议UISearBarDelegate，无数据源协议</p></li>
<li><p>搜索功能的添加</p>

<ol>
<li>增加NSMutableArray实例listFilterTeams，并赋初值listTeams。</li>
<li>tableView中使用listTeams显示的内容，使用listFilterTeams显示。</li>
<li><p>增加搜索功能，方法filterContectForSearchText的定义</p>

<pre><code>-(void)filterContectForSearchText:(NSString*)searchText scope:(NSUInteger)scope
{
if ([searchText length] == 0) {
self.listFilterTeams = [[NSMutableArray alloc] initWithArray:self.listTeams];
return;
}
NSPredicate *scopePredicate;
NSArray *tempArray;
switch (scope) {
case 0:
    scopePredicate = [NSPredicate predicateWithFormat:@&quot;SELF.name contains[c] %@&quot;,searchText];
    tempArray = [self.listTeams filteredArrayUsingPredicate:scopePredicate];
     self.listFilterTeams = [NSMutableArray arrayWithArray:tempArray];
     break;
case 1:
    scopePredicate = [NSPredicate predicateWithFormat:@&quot;SELF.image contains[c] %@&quot;,searchText];
    tempArray = [self.listTeams filteredArrayUsingPredicate:scopePredicate];
    self.listFilterTeams = [NSMutableArray arrayWithArray:tempArray];
    break;
default:
    self.listFilterTeams = [NSMutableArray arrayWithArray:self.listTeams];
    break;
}
}
</code></pre></li>
<li><p>注意预言NSPredicate的使用<code>SELF.name contains[c]</code></p>

<pre><code>scopePredicate = [NSPredicate predicateWithFormat:@&quot;SELF.name contains[c] %@&quot;,searchText];
tempArray = [self.listTeams filteredArrayUsingPredicate:scopePredicate];
</code></pre></li>
<li><p>搜索栏控制器的添加</p>

<ol>
<li><p>添加一个UISearController并实例化，添加到table的header</p>

<pre><code>self.searchController = [[UISearchController alloc]initWithSearchResultsController:nil];
self.searchController.searchResultsUpdater = self;
self.searchController.dimsBackgroundDuringPresentation = FALSE;
self.searchController.searchBar.scopeButtonTitles = [NSArray arrayWithObjects:@&quot;中文&quot;,@&quot;English&quot;,nil];
self.searchController.searchBar.delegate = self;
self.searchController.searchBar.placeholder = @&quot;Country Search&quot;;
self.tableView.tableHeaderView = self.searchController.searchBar;
[self.searchController.searchBar sizeToFit];
</code></pre></li>
<li><p>代理方法的添加</p>

<pre><code>-(void)searchBarResultsListButtonClicked:(UISearchBar *)searchBar
{
[self updateSearchResultsForSearchController:self.searchController];
}
-(void)updateSearchResultsForSearchController:(UISearchController *)searchController
{
 NSString* searchString = searchController.searchBar.text;
 [self filterContectForSearchText:searchString scope:self.searchController.searchBar.selectedScopeButtonIndex];
 [self.tableView reloadData];
 }
</code></pre></li>
</ol></li>
</ol></li>
</ol></li>
<li><p>分节表视图</p>

<ol>
<li><p>索引使用原则</p>

<pre><code>    1. 索引标题不能与显示的标题完全一样
    2. 索引标题应该具有代表性
    3. 如果有索引视图，一般就去掉扩展视图
</code></pre></li>
<li><p>添加索引，引起数据组织类型的变化，因此增加Dictionary用于索引</p></li>
<li><p>增加Array用于储存组名，并显示为SeactionHeader的title</p>

<pre><code>    -(NSArray*)sectionIndexTitlesForTableView:(UITableView *)tableView
    {
     NSMutableArray *listTitles = [[NSMutableArray alloc]init];
     for (NSString* item in self.listGroup) {
     NSString *title = [item substringToIndex:1];
     [listTitles addObject:title];
     }
     return listTitles;
     }
</code></pre></li>
<li><p>显示每个Section下的内容</p>

<pre><code>    -(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
    {
    return [self.listGroup count];
    }
    -(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
    {
    NSString* sectionName = [self.listGroup objectAtIndex:section];
    return [[self.dicData objectForKey:sectionName]count];
    }
    -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
    {
    CustomCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cellIdentifier&quot;];
    NSUInteger row = indexPath.row;
    NSUInteger section = indexPath.section;
    NSString *sectionName = self.listGroup[section];
    NSDictionary *resourceDic = [[self.dicData objectForKey: sectionName] objectAtIndex:row];
    cell.textLabel.text = resourceDic[@&quot;name&quot;];
    cell.detailTextLabel.text = [resourceDic objectForKey:@&quot;image&quot;];
    cell.imageView.image = [UIImage imageNamed:[resourceDic objectForKey:@&quot;image&quot;]];
    cell.accessoryType = UITableViewCellAccessoryDetailDisclosureButton;
    return cell;
    }
</code></pre></li>
<li><p>添加索引</p>

<pre><code>    -(NSArray*)sectionIndexTitlesForTableView:(UITableView *)tableView
    {
    NSMutableArray *listTitles = [[NSMutableArray alloc]init];
    for (NSString* item in self.listGroup) {
    NSString *title = [item substringToIndex:1];
    [listTitles addObject:title];
    }
    return listTitles;
    }
</code></pre></li>
<li><p>分组</p>

<pre><code>    self.tableView  = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStyleGrouped];
</code></pre></li>
</ol></li>
<li><p>静态表与界面布局</p>

<ol>
<li><p>静态表使用特点</p>

<pre><code>1. 只能使用在storyBoard中，不能在Xib中使用，更不能代码实现
2. 静态表所在的视图控制器必须是UITableViewController
3. 静态表不需要实现表视图的委托与数据源协议
</code></pre></li>
</ol></li>
<li><p>单元格的插入与删除</p>

<ol>
<li><p>新建工程DeleteAddCell，删除ViewController，拖拽NavigationController到界面</p>

<pre><code>1. 添加Navigation Controller同时会添加Root View Controller
2. 导航控制器Navigation Controller是整个应用的根视图控制器
3. 表视图控制器Root View Controller是导航控制器的根视图控制器              
</code></pre></li>
<li><p>实现</p>

<pre><code>1. 修改父类ViewController为UITableViewController
2. 添加TextField到ViewController Scene中，并设置Font为Sys 20
3. 声明编辑按钮:self.navigationItem.rightBarButtonItem = self.editButtonItem;
4. 显示内容，实现“numberOfRowsInSection” 与 “cellForRowAtIndexPath”
5. 添加tableView edit style的分类显示显示“editingStyleForRowAtIndexPath”
6. 实现删除和插入处理“commitEditingStyle”，注意不仅需要操作data，还需要实现tableView的indexPath的操作
7. highLight显示“shouldHighlightRowAtIndexPath”
</code></pre></li>
<li><p>Cell的移动</p>

<pre><code>1.  单元格的后面会有重排序按钮
2. 需要实现DataSource方法，tableView:canMoveRowAtIndexPath:与tableView:moveRowAtIndexPath:toIndexPath:
</code></pre></li>
</ol></li>
<li><p>表视图UI设计模式</p>

<ol>
<li>两个模式，移动平台开发标准，分页模式与下拉模式(Pull-To-Refresh)</li>
<li><p>分页模式</p>

<pre><code>1. 数据量很大时，一次返回所有信息会严重影响应用性能，此时会考虑分页模式
2. 根据触发模式的不同，请求分为主动请求与被动请求
3. 主动请求，条件满足时，自动发出请求，表脚会有活动指示器，请求结束后隐藏指示器
4. 被动请求模式，条件满足时，表脚会出现响应点击事件控件，点击发送请求，请求结束后隐藏控件
</code></pre></li>
<li><p>下拉刷新模式</p>

<pre><code>1. 与分页相反，屏幕到顶部时，再往下拉，会重新请求数据，表头会出现活动指示器
2. Pull down to refresh
3. Release to Refresh
4. Loading
</code></pre></li>
<li><p>下拉刷新控件</p>

<pre><code>1. UITableViewController 添加了一个refreshControl属性
2. refreshControl属性是UIRefreshControl类型
3. UIRefreshControl是表视图实现下拉刷新而提供的类
4. 下拉刷新控件布局会被UITableViewController自动置于顶部，不必考虑
5. 我们只需要设置refreshControl的状态即可
</code></pre></li>
<li><p>Code</p>

<ol>
<li><p>add refresh in ViewDidLoad</p>

<pre><code>self.refreshControl = [[UIRefreshControl alloc]init];
self.refreshControl.attributedTitle = [[NSAttributedString alloc] initWithString:@&quot;Pull Down Refresh&quot;];
[self.refreshControl addTarget:self action:@selector(refreshTableView)forControlEvents:UIControlEventValueChanged];
</code></pre></li>
<li><p>add the select</p>

<pre><code>-(void)refreshTableView
{
 if (self.refreshControl.refreshing) {
 self.refreshControl.attributedTitle = [[NSAttributedString alloc] initWithString:@&quot;Reloading ...&quot;];
 [self.listTeams insertObject:@&quot;Add Refresh City&quot; atIndex:0];
 [self.refreshControl endRefreshing];
 self.refreshControl.attributedTitle = [[NSAttributedString alloc] initWithString:@&quot;Pull Down Refresh&quot;];
 [self.tableView reloadData];
 }
 }
</code></pre></li>
<li><p>more important</p>

<pre><code>[self.refreshControl endRefreshing];
[self.tableView reloadData];
</code></pre></li>
</ol></li>
</ol></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-28T16:31:24+08:00" itemprop="datePublished">2017/3/28</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14906898842206.html" itemprop="url">
		第五章：委托协议，数据源协议与高级视图</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li><p>协议</p>

<pre><code>1. 高级视图的功能比较复杂，需要将某些复杂功能从视图本身剥离出来，由另外一些遵守该视图指定协议的类来完成。
2. 简单一些的视图只指定了委托协议，如UITextField,UITextView,命名规则为&quot;视图名+Delegate&quot;
3. 对于复杂的视图，我们同时指定委托协议与数据源协议，如UIPickerView，UICollectionView和UITableView，命名规则&quot;视图名+DataSource&quot;
4. 委托协议和数据源协议是OSX 与iOS非常重要的设计模式。
5. 委托对象负责对控件的外观与事件状态变化做出反应
6. 数据源对象是控件与应用数据的桥梁
7. 委托方法一般是可选择的，而数据源方法是必须实现的
</code></pre></li>
<li><p>选择器UIPickerView</p>

<ol>
<li>选择器是iOS中的标准控件，主要用于为用户提供选择，有输入的地方，就需要验证.</li>
<li><p>日期选择器UIdatePicker</p>

<pre><code>1. 有四种模式，日期，日期时间，时间，和倒计时定时器
2. Mode: Date and Time,Time,Date,Count Down Timer
3. Locate:本地化
4. Interval:间隔时间，单位分钟
5. Date:设定开始时间
6. Constraints:约束，最大和最小日期
7. Timer：倒计时模式下倒计时的秒数
8.  NSDate *date = self.datePicker.date;
     NSLog(@&quot;the date picked is :%@&quot;,[date descriptionWithLocale:[NSLocale currentLocale]]);
     NSDateFormatter *formate = [[NSDateFormatter alloc]init];
     [formate setDateFormat:@&quot;YYYY-MM-dd HH:mm:ss&quot;];
     self.label.text = [formate stringFromDate:date];
</code></pre></li>
<li><p>普通选择器</p>

<pre><code>#pragma mark picker datasource
-(NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView
{
return 3;
}
-(NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component
{
if (component == 0) {
return [self.pickerProvincesData count];
}else
return [self.pickerCitiesData count];
}
#pragma mark picker delegate
-(NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component
{
 if (component == 0) {
 return [self.pickerProvincesData objectAtIndex:row];
  }else
       return [self.pickerCitiesData objectAtIndex:row];
 }
 -(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component
 {
  NSLog(@&quot;Selected:Row:%lu,Component:%lu&quot;,row,component);
  if (component==0) {
  self.pickerCitiesData = [self.pickerData  objectForKey:[self.pickerProvincesData objectAtIndex:row]];
  [self.pickerView reloadComponent:1];
  [self.pickerView reloadComponent:2];
  }
  }
</code></pre></li>
<li><p>集合视图 UICollectionView</p>

<ol>
<li>为了增强网格视图开发，iOS开放了集合石图UICollection API</li>
<li><p>集视图的组成</p>

<pre><code>1. 单元格      =&gt; Cell 自定义
2. 节    (Section) =&gt; equal to Row
3. 补充视图
4. 装饰视图
5. NSIndexPath =&gt;have 2 attributes, row and section
</code></pre></li>
<li><p>UICollectionView</p>

<pre><code>1. UICollectionView继承自UIScrollView
2. 两个协议UICollectionViewDelegate（委托协议）与UICollectionViewDataSource（数据源协议）
3. 视图包括单元格UICollectionViewCell
4. 布局为UICollectionViewLayout，为抽象类，子类UICollectionViewFlowLayout
5. 对应的控制器为UICollectionViewController
</code></pre></li>
<li><p>CollectionView Code</p>

<pre><code>1. UICollectionView  object 拖拽到视图，并设置代理
2. 自定义UICollectionViewCell，并应用到UICollectionView
3. 视图中，布置Cell的内容与大小
4. 实现UICollectionViewDelegate与UICollectionViewDataSource，并显示内容
5. 
</code></pre></li>
</ol></li>
</ol></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-27T08:47:21+08:00" itemprop="datePublished">2017/3/27</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14905756410535.html" itemprop="url">
		第四章 UIView与视图</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li><p>标签(Label)与按钮(Button)</p>

<ol>
<li>视图与控件是iOS应用的基本元素</li>
<li><p>LabelButton工程的创建</p>

<pre><code>1. Label的加入，在右边栏使用属性检查器，查看属性
2. 对象库(Object Library)中搜索控件，
3. Label -&gt; Label,View
4. Button -&gt; Button, Control , View
5. UIKit中至少两种按钮,UIButton与UIBarButtonItem(Not SubClass From NSView)
6. 按钮事件处理，Interface Builder实现按钮与方法之间的连线
7. 辅助编辑器，选中Button，同时按住&quot;Control&quot;,鼠标拖拽到辅助编辑器，注意各个参数
8. 代码实现事件，`[self.button addTarget:self action:@selector(onClick:) forControlEvents:UIControlEventTouchUpInside];`
包括，事件处理者，事件处理方法，事件类型
9. 代码中，事件处理方法的返回类型不必为IBAction，也可以为void
10. action可以有多重形式，每一个冒号后面都有一个参数
</code></pre></li>
</ol></li>
<li><p>访问视图</p>

<pre><code>    1. 关键字&quot;Outlet&quot;来修饰属性（称为输出口属性），用于关联视图与属性
    2. 在storyBoard或Xib中创建视图，所有权是Interface Builder，它们对视图对象是强引用的。由于所有权不属于Controller因此在Controller中使用时不能定义为strong
    3. 如果代码生成视图，则属性所有权属于Controller，需要定义为strong。否则定义为weak内存会立刻释放
</code></pre></li>
<li><p>TextField与TextView</p>

<pre><code>    1. Label，TextField与TextView都属于文本视图，内容编辑都可以通过代码，双击控件，属性检查器中text属性来实现。
    2. TextField与TextView比Label多了一个键盘的设置，还有一个委托协议，“textFieldShouldReturn:”，“textView:shouldChangeTextInRange:replacementText:”
    3. Delegate代理可以通过IB，将TextField与TextView的属性Delegate与Controller 相连，实现对象的委托
    4. Delegate也可以通过&quot;code，self.field.delegate = self; self.viewText.delegate = self;&quot;来实现
</code></pre></li>
<li><p>键盘的打开与关闭</p>

<ol>
<li>键盘的打开，一旦处于编辑状态，系统智能弹出键盘</li>
<li>键盘的关闭，需要放弃第一响应者的身份，需要调用UIResponder的resignFirstResponder，可以在delegate方法中实现：如<q>[textView resignFirstResponder];</q></li>
<li><p>键盘通知</p>

<pre><code>1. 关闭键盘&quot;UIKeyboardDidHideNotification&quot;
2. 打开键盘&quot;UIKeyboardDidShowNotification&quot;
3. 注册: -(void)viewWillAppear:(BOOL)animated{
NSLog(@&quot;Hello this is :View Will Appear&quot;);
[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(keyBoardDidShow:) name:UIKeyboardDidShowNotification object:nil];
[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(keyBoardDidHide:) name:UIKeyboardDidHideNotification object:nil];
}
4. 注销:-(void)viewWillDisappear:(BOOL)animated{
 [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardDidShowNotification object:nil];
 [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardDidHideNotification object:nil];
 NSLog(@&quot;Hello this is :View Will DisAppear&quot;)
 }
 5. 键盘的类型，属性检测器中&quot;Keyboard Type&quot;修改
 6. return key的文本设置，属性检测器中&quot;Keyboard Type&quot;修改
 7. 与视图的其他属性一样，这些同样可以使用代码设置
</code></pre></li>
</ol></li>
<li><p>开关控件，分段控件，滑块控件</p>

<ol>
<li>UISwitch,UISegmentedControl,UISlider都是UIControl的子类</li>
<li><p>UISwitch,link it to <q>switchValueChanged</q></p>

<pre><code>-(IBAction)switchValueChanged:(id)sender {
UISwitch *switchBoth = (UISwitch*)sender;
[self.leftSwitch setOn:switchBoth.isOn animated:TRUE];
[self.rightSwitch setOn:switchBoth.isOn animated:TRUE];
}
</code></pre></li>
<li><p>UISegmentedControl类似于Windows中的单选按钮 </p>

<pre><code>1. the segment can set to more the 2 segments
2. - (IBAction)touchDown:(id)sender {
UISegmentedControl *segment = (UISegmentedControl*)sender；
[self.leftSwitch setHidden:FALSE];
[self.rightSwitch setHidden:FALSE];
if (segment.selectedSegmentIndex == 0) {
[self.leftSwitch setOn:TRUE animated:TRUE];
[self.rightSwitch setOn:TRUE animated:TRUE];
}else if(segment.selectedSegmentIndex == 1){
[self.leftSwitch setOn:FALSE animated:TRUE];
[self.rightSwitch setOn:FALSE animated:TRUE];
}else{
[self.leftSwitch setHidden:TRUE];
[self.rightSwitch setHidden:TRUE];}
}
</code></pre></li>
<li><p>UISlider</p>

<pre><code>1. 属性检测器设置Minimum,Maximum,Current
2. - (IBAction)sliderValueChange:(id)sender {
UISlider *slider = (UISlider*)sender;
self.sliderLabel.text = [NSString stringWithFormat:@&quot;Slider Value is : %.2f&quot;,slider.value];
}
</code></pre></li>
</ol></li>
<li><p>Web 视图<q>WKWebView</q></p>

<ol>
<li><p>Web 技术构建界面有很大优势</p>

<pre><code>1. 丰富的界面布局
2. 显示多行不同风格文本
3. 显示图片，播放音频/视频等
4. 显示HTML
5. 解析CSS
6. 执行JavaScript
7. MKWebView，可以加载本地HTML和网络资源
</code></pre></li>
<li><p>MKWebView</p>

<pre><code>1. 加载本地HTML，一般采用同步方式&quot;loadHTMLString&quot;,&quot;loadData&quot;
2. 加载网络资源一般采用异步方式,&quot;loadRequest&quot;
3. object Library库中没有该控件，所以需要使用代码生成
     self.webView = [[WKWebView alloc]initWithFrame:CGRectMake(0, 60, screen.size.width, screen.size.height-80)];
     [self.view addSubview:self.webView];
4. navigationDelegate, didStartProvisionalNavigation, didCommitNavigation, didFinishNavigation, didFailProvisionalNavigation
5. Info file add dic(App Transport Security settings,Allow Arbitrary Loads)
</code></pre></li>
</ol></li>
<li><p>警告框与操作表</p>

<pre><code>1. AlertView and ActionSheet
2. UIAlertController 实现警告框与操作表

        1. 警告框是模态的，因此不能随意使用，使用情况如下
        2. 应用不能继续运行
        3. 询问另外的解决方案
        4. 询问对操作的授权
        5. 警告框的按钮不应多于两个，否则为操作表
        6. IOS 8 之前使用UIAlertView，之后使用UIAlertController
        7. 控件库中没有可拖拽对象，因此需要code实现
        8. 区别两者为alert的type：UIAlertControllerStyleActionSheet， UIAlertControllerStyleAlert
3. AlertViewActionSheet

            UIButton *btn = (UIButton*)sender;
            NSLog(@&quot;the button item: %@&quot;,btn.currentTitle );
            UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;AlertMessage&quot; message:@&quot;Alert test goes here!&quot; preferredStyle:UIAlertControllerStyleActionSheet];
            UIAlertAction *noAction = [UIAlertAction actionWithTitle:@&quot;NO&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction *action){
            NSLog(@&quot;Tap NO Button: %@&quot;,action.title);
            }];
            UIAlertAction *yesAction = [UIAlertAction actionWithTitle:@&quot;YES&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action){
            NSLog(@&quot;Tap YES Button:%@&quot;,action.title);
            }];
            UIAlertAction *destructionAction = [UIAlertAction actionWithTitle:@&quot;Destruction&quot; style:UIAlertActionStyleDestructive handler:^(UIAlertAction *action){
            NSLog(@&quot;Tap Destruction Button:%@&quot;,action.title);
            }];
            UIAlertAction *otherAction = [UIAlertAction actionWithTitle:@&quot;DownLoad&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action){
            NSLog(@&quot;Tap Other Button:%@&quot;,action.title);
            }];
            [alertController addAction:noAction];[alertController addA
            ction:yesAction];
            [alertController addAction:destructionAction];
            [alertController addAction:otherAction];
            [self presentViewController:alertController animated:YES completion:^{
            NSLog(@&quot;the alert is appear !&quot;);
            }];
</code></pre></li>
<li><p>活动指示器 ActivityIndicatorView，UIProgressView</p>

<ol>
<li>可以直接拖拽控件</li>
<li><p>UploadDownLoad</p>

<ol>
<li><p>UIActivityIndicatorView</p>

<pre><code>if (self.activityIndicatorView.isAnimating) {
[self.activityIndicatorView stopAnimating];
}else
[self.activityIndicatorView startAnimating];
</code></pre></li>
<li><p>UIProgressView</p>

<pre><code>1. self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(downLoad) userInfo:nil repeats:YES];
2. -(void)downLoad{
self.progressView.progress = self.progressView.progress + 0.1;
if (self.progressView.progress == 1) {
[self.timer invalidate];
UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;DownLoad Completed&quot; message:@&quot;successed&quot; preferredStyle:UIAlertControllerStyleAlert];
UIAlertAction *action = [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:nil];
[alert addAction:action];
[self presentViewController:alert animated:YES completion:nil];             
}
}
</code></pre></li>
</ol></li>
</ol></li>
<li><p>工具栏与导航栏</p>

<ol>
<li>ToolBar与NavigationBar差别很大，但是有一个共性，可以放置UIBarButtonItem</li>
<li>工具栏主要应用于当前界面，考虑的是局部界面</li>
<li>导航栏主要应用于导航，考虑的是整个应用</li>
<li><p>工具栏 UIToolBar</p>

<pre><code>1. iphone工具栏位于屏幕底部，ipad位于顶部
2. iphone 最多可以显示5个按钮
3. 按钮之间有固定空格或可变空格可以选择
4. 除了UIBarButtonItem，还可以放置其他自定义视图
5. UIToolBar一定要有一个ButtonItem的itentifier属性设置为Save
6. 两个Item之间需要添加可变空格，这样显示漂亮
</code></pre></li>
<li><p>导航栏 </p>

<pre><code>1. UINavigationController, 构建树形导航模式应用的根控制器
2. UINavigationBar，导航栏，与导航栏控制器是1对1的关系，可以包含多个导航栏项目。
3. UINavigationItem，导航栏项目，左中右三个区域，左返回，右按钮，中间描述性标题，包含栏按钮项目
4. UIBarButtonItem，导航栏项目中的左右按钮
</code></pre></li>
</ol></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-25T10:21:10+08:00" itemprop="datePublished">2017/3/25</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14904084706929.html" itemprop="url">
		第三章Cocoa Touch</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li><p>简介</p>

<pre><code>1. 界面基本都是有Cocoa与Cocoa Touch框架中元素搭建
2. 这些元素通过MVC框架(Model-View-Controller)组织起来的
3. OSX的核心是Foundation与Application Kit
4. iOS的核心是Foundation与UIKit
5. MVC，中VC是UIKit中的UIView与UIController
</code></pre></li>
<li><p>UIViewControl 视图控制器</p>

<ol>
<li><p>Categary</p>

<pre><code>1. UIViewController,导航作用，可以用于两个界面之间的跳转
2. UINavigationController，与UITableViewController结合使用，构建树形结构导航模式
3. UITabBarController，标签栏控制器
4. UIPageViewController，电子书风格导航控制器
5. UISplitViewController，屏幕分割几块，主要为iPad屏幕设计
6. UIPopoverController，气泡风格视图控制器
7. 作用，显示视图，界面跳转(导航)
</code></pre></li>
<li><p>视图生命周期</p>

<ul>
<li><p>视图有不同的状态，这就是生命周期。视图生命周期的不同阶段会回调视图控制器(viewController)的不同方法</p>

<pre><code>1. 视图创建，调用viewDidLoad，only once
2. 视图可见，调用viewWillAppear，viewDidAppear，more one
3. 视图不可见，调用viewWillDisappear，viewDidDidappear，more
4. 系统低内存，调用didReceiveMemoryWarning，release Memory
</code></pre></li>
</ul></li>
<li><p>UIView</p>

<ol>
<li>UIView是所有视图的根类，<code>UIView:UIResponder:NSObject</code></li>
<li><p>NSView的继承层次结构</p>

<pre><code>1. UIWindow
2. UILabel
3. UITableViewCell
4. UIScrollView     -&gt; UITableView,UITextView,UICollectionView
5. UIPickerView
6. UIProgressView
7. UIActivityIndicatorView
8. UIImageView
9. UITabBar
10. UIToolbar （Bottom/Upside）
11. UIControl       -&gt; UIButton,UIDatePicker,UIPageControl,UISegmentedControl,UITextField,UISlider,UISwitch
12. UINavigationBar
13. UIActionSheet
14. UIAlertView
15. UIVebView
</code></pre></li>
<li><p>基本属性</p>

<pre><code>1. frame,CGSize{CGFloat width; CGFloat height;};
2. center,CGPoint{CGFloat x; CGFloar y;};
3. bounds,CGRect{CGPoint origin; CGSize size;};
</code></pre></li>
<li><p>视图分类</p>

<pre><code>1. 控件，继承自UIControl类,响应用户高级事件
2. 窗口，UIWindow，only one，是所有视图的跟容器
3. 容器视图，UIScrollView，UIToolbar
4. 显示视图，UIImageView,UILabel,UIProgressView,UIActivityIndicatorView
5. 文本和Web视图,UITextView，UIWebView
6. 导航视图，UITabViewBar，UINavigationBar
7. 警告框和操作表，pop up/Bottom up
</code></pre></li>
<li><p>界面构建层次</p>

<pre><code>1. 应用界面的构建层次为，树形结构
2. 树根(Window)，树干(RootView)与树冠(Other View objects)
3. 视图的三个属性,superView,subViews,window
4. Window(UIwindow)-&gt;RootView(UIView)-&gt;Button,Label,View
</code></pre></li>
<li><p>界面构建</p>

<pre><code>* 三种方式,故事版文件storyboard，XIB文件，纯代码实现
</code></pre></li>
</ol></li>
</ol></li>
<li><p>故事版StoryBoard</p>

<ol>
<li>本质为一个xml文件，描述界面，界面中的视图，视图布局，事件处理，以及界面导航</li>
<li>我们可以创建Master-Detail, Page-Based,Single View,Tabbed,Game等导航模式的应用</li>
<li><p>storyBoard中的两个重要概念,Scene,Segue.</p>

<pre><code>1. Scene包括ViewController，and View
2. Scene的导航(Navigation)通过&quot;过渡&quot;(Segue)连接
3. 导航模式与过渡类型紧密相关
4. Show Segue，Show Detail Segue，Model Segue，Popover Segue
</code></pre></li>
<li><p>树形结构导航模式，模态导航模式</p></li>
<li><p>story board</p>

<pre><code>1. create a story board named &quot;SN&quot;
2. drag a UIViewController to the board
3. change UIViewController to initial view controller(Entry Point)
4. target-&gt;General-&gt;deployment Info-&gt;Main Interface = &quot;SN&quot;
</code></pre></li>
</ol></li>
<li><p>Xib 文件构建界面</p>

<ol>
<li>delete main.storyboard file 与Controller</li>
<li>create a cocoa file with Xib，subClass from UIViewController</li>
<li>set target-&gt;General-&gt;deployment Info -&gt;Main Interface = nil</li>
<li><p>in delegate file ,change below code to load xib file</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 
{

    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    self.window.rootViewController = [[UIViewController alloc]initWithNibName:@&quot;RootViewController&quot; bundle:nil];
    [self.window makeKeyAndVisible];
    return YES;
}
</code></pre></li>
</ol></li>
<li><p>code 构建界面</p>

<ol>
<li>delete main.storyboard file 与Controller</li>
<li>create a cocoa file “RootViewController” no Xib，subClass from UIViewController</li>
<li>set target-&gt;General-&gt;deployment Info -&gt;Main Interface = nil</li>
<li><p>in delegate file ,change below code to load xib file</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 
{

    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    self.window.rootViewController = [[RootViewController alloc]init];
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];
    return YES;
}    
</code></pre></li>
<li><p>in RootViewController，change the code</p>

<pre><code>- (void)viewDidLoad {
[super viewDidLoad];
CGRect screen = [[UIScreen mainScreen] bounds];
CGFloat width = 90;
CGFloat height = 20;
CGFloat topView = 150;
UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake((screen.size.width - width)/2, topView, width, height)];
label.text = @&quot;Hello World&quot;;
[self.view addSubview:label];
}
</code></pre></li>
<li><p>视图属性</p>

<pre><code>1. frame -&gt;该视图在父视图坐标系统中的位置与大小，相对父视图
2. bounds -&gt; 该视图在本地坐标系统中的位置与大小，相对于自己
</code></pre></li>
<li><p>Interface Builder (IB),可交互原型</p></li>
</ol></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-24T14:55:55+08:00" itemprop="datePublished">2017/3/24</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14903385553004.html" itemprop="url">
		第二章 First iOS Program</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li>Hello Word application create</li>
<li><p>应用程序生命周期</p>

<pre><code>1. Not Running，非运行，没有运行或被系统终止
2. Inactive，前台非活动，正在进入前台，还不能接受事件处理
3. Active，前台活动，进入前台可以进行事件处理
4. Background，后台状态，进入后台状态，正在运行代码则执行，完毕后挂起
4. Suspended，挂起状态，不执行代码，内存不够则终止
5. Not Running -&gt; Inactive -&gt; Active 
6. Active -&gt;Inactive - &gt; Background-&gt; Suspended -&gt; Not Running
7. Home 键两次按压可以进入iOS多任务栏
8. Suspended -&gt; Background -&gt; Inactive -&gt; Active
</code></pre></li>
<li><p>Product 与 Target</p>

<pre><code>1. Info.plist文件，工程属性文件，产品(Product)-&gt;目标(Target)-&gt;工程(Project) 
2. 一个产品就是一个目标，多个目标可以属于同一个工程
3. 目标继承了工程的设置，而且还可以覆盖工程的设置
4. 多个Target时，可以通过Scheme来选择目前运行的Target
5. Target-&gt;General-&gt;Demployment Target (Device Orientation, Devices)
</code></pre></li>
<li><p>iOS API</p>

<ol>
<li><p>Cocoa Touch</p>

<pre><code>1. 提供了iOS的基本服务(多任务，触摸，输入，推送通知)和关键框架
2. ContactsUI,CN,通信录UI
3. EventKitUI,EK,日历事件数据
4. GameKit,GK,点对点网络通信
5. iAd,AD,应用中嵌入广告
6. MapKit,MK,应用中嵌入地图和地理信息编码等
7. MessageUI,MF,提供与发送电子邮件相关API
8. PhotoUI,PH,照片UI相关API
9. Twitter,TW,发送Twitter接口
10. UIKit,UI,提供UI类
11. WatchKit,WK,Apple Watch开发相关类
</code></pre></li>
<li><p>Media</p>

<pre><code>1. 提供了图形，音频，视频和AirPlay技术
2. Assets Library, AL，提供访问图片和视频的接口
3. AudioToolbox，Audio,录制或播放音频，音频流以及各式转换
4. AudioUnit，Audio，AU，使用内置音频单元服务以及音频处理模块
5. AV Foundation，AV提供播放与录制音频和视频的OBJC接口
6. Core Audio，Audio，提供录制，制作播放音频的C接口
7. Core Graphics，CG，提供Quartz 2D接口
8. Core Image，CI，提供操作视频和静态图像的接口
9. Core MIDI，MIDI，提供处理MIDI数据底层的API
10. Core Text，CT，提供渲染文本和处理字体的简单，高效C语言接口
11. Core Video，CV，提供用于处理音频和视频的API
12. Image I/O，CG，包含读写图像数据类
13. GLKit，GLK，构建复杂的OPENGL ES应用的OBJC实用类
14. Media Player，MP，包含全屏播放窗口
15. OpenAL，AL，跨平台音频C接口
16. OpenGL ES，EAGL，GL，跨平台2D、3D图形库
17. Quartz Core，CA，动画接口
18. Sprite Kit，SK，2D游戏开发引擎
19. Scene Kit，SCN，3D图形框架
</code></pre></li>
<li><p>Core Services</p>

<pre><code>1. Accounts, AC,用于访问twitter账户
2. Contacts， CN， 用于访问通讯录信息
3. AdSupport， AS，获得iAD广告标识
4. CFNetwork， CF，提供访问Wi-Fi网络和蜂窝煤电话网络的API
5. Core Data，NS，提供管理应用数据的ORM接口
6. CoreFoundation，CF，他是iOS开发最基础的框架，包括数据集
7. Core Location，CL，定位服务的API
8. Core Media，CM，AV Foundation底层媒体类型，音频或视频展示
9. CoreMotion，CM 接受和处理重力加速计以及其他的运行事件
10. CoreTelephony，CT，提供电话基本信息的API
11. Event Kit，EK，访问日历事件数据
12. Foundation， NS，Core Foundation框架的OBJC封装
13. JavaScriptCore JS 实现OC与JavaScript之间的调用
14. MobileCoreServices，UT，统一类型标示符(UTI),使用的底层
15. Newsstand Kit，NK，后台下载杂志，新闻的API接口
16. Pass Kit，PK，访问优惠券API
17. QuickLook， QL，预览无法直接查看的内容
18. Social ，SL，提供社交网络访问API，中国新浪API
19. Store Kit，SK，应用内置收费资金交易
20. SystemConfiguration SC，设备网络配置
21. Cloud Kit，CK，开发iCloud的新型API
22. Health Kit，HK，开发健康和健身服务的API
23. Home Kit，HM，与家中设备通信并进行控制
4. 
</code></pre></li>
<li><p>Core OS</p>

<pre><code>1. Acceerate ，AC ，访问重力加速计API
2. Core Bluetooth，CB，访问低能耗蓝牙设备API
3. External Accessory，EA，访问外围配件API
4. Generic Security Services，gss，提供安全相关服务
5. Security ，CSSM，Sec 管理证书，公钥，私钥，和安全信息策略
6. LocalAuthentication，LA，通过用户指定策略进行安全认证
</code></pre></li>
</ol></li>
<li><p>API帮助</p>

<ol>
<li>代码中选中方法，右键直接jump to define</li>
<li>间接文档，选中方法，右边快捷帮助检查器<q>?</q>，Alt+单击方法</li>
<li>全面文档，Alt+双击方法</li>
</ol></li>
</ol>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-24T14:20:37+08:00" itemprop="datePublished">2017/3/24</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="14903364377953.html" itemprop="url">
		第一章 BriefiOS</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ol>
<li><p>Xcode 界面</p>

<ol>
<li>菜单栏</li>
<li>工具栏</li>
<li>导航面板</li>
<li>代码编辑区</li>
<li>检查器，文件检查器，属性检查器，标识检查器，尺寸检查器</li>
</ol></li>
<li><p>图示约定 </p>

<ol>
<li>圈框，重点说明内容</li>
<li>箭头，用户操作，拖拽</li>
<li>虚线，设置控件的属性</li>
<li>手势，点击，触摸，滑动等</li>
</ol></li>
<li><p>方法命名约定</p>

<ol>
<li>多重参数方法命名，参数类型，参数变量，方法返回值，方法签名API，方法标示符。</li>
<li>标示符,<q>-</q>代表实例方法，“+”代表类方法</li>
<li>标示符“:”,表示有参数</li>
<li>构造函数，<code>initWithFrame:style:</code></li>
</ol></li>
<li><p>错误机制处理</p>

<ol>
<li>Swift 使用的是<code>do-try-catch</code>错误处理模式，Objc使用的是传递&amp;error(NSError地址)，发生错误则error不为nil，不发生则为nil</li>
</ol></li>
</ol>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>




</body>
</html>